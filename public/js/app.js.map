{"version":3,"names":[],"mappings":"","sources":["app.js"],"sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar SocketChannel = function () {\n    function SocketChannel(chatApp) {\n        _classCallCheck(this, SocketChannel);\n\n        this.chatApp = chatApp;\n        this.url = \"http://192.168.10.10:4444/\";\n        this.socket = io(this.url);\n        this.channel = 'app-messages-channel:App\\\\Events\\\\Message\\\\IncomingMessage';\n        this.listen();\n    }\n\n    _createClass(SocketChannel, [{\n        key: \"listen\",\n        value: function listen() {\n            var _this = this;\n\n            this.socket.on(this.channel, function (message) {\n                _this.chatApp.receiveMessage(message);\n            });\n        }\n    }]);\n\n    return SocketChannel;\n}();\n\nexports.default = SocketChannel;\n\n},{}],2:[function(require,module,exports){\n'use strict';\n\nvar _ChatApp = require('./components/ChatApp');\n\nvar _ChatApp2 = _interopRequireDefault(_ChatApp);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nReactDOM.render(React.createElement(_ChatApp2.default, null), document.getElementById('chatApp'));\n\n},{\"./components/ChatApp\":3}],3:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _ChatSendForm = require('./ChatSendForm');\n\nvar _ChatSendForm2 = _interopRequireDefault(_ChatSendForm);\n\nvar _ChatMessages = require('./ChatMessages');\n\nvar _ChatMessages2 = _interopRequireDefault(_ChatMessages);\n\nvar _SocketChannel = require('../SocketChannel');\n\nvar _SocketChannel2 = _interopRequireDefault(_SocketChannel);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar ChatApp = function (_React$Component) {\n    _inherits(ChatApp, _React$Component);\n\n    function ChatApp(props) {\n        _classCallCheck(this, ChatApp);\n\n        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(ChatApp).call(this, props));\n\n        _this.state = {\n            messages: []\n        };\n\n        _this.socket = new _SocketChannel2.default(_this);\n\n        _this.sendMessage = _this.sendMessage.bind(_this);\n        return _this;\n    }\n\n    _createClass(ChatApp, [{\n        key: 'receiveMessage',\n        value: function receiveMessage(message) {\n            var msg = message.data.message;\n            var datetime = moment(message.data.datetime.date).format('MM/DD/YYYY h:m:s A');\n\n            this.setState({\n                messages: [].concat(_toConsumableArray(this.state.messages), [{ message: msg, time: datetime }])\n            });\n        }\n    }, {\n        key: 'sendMessage',\n        value: function sendMessage(message) {\n            var url = \"messages\";\n            new Promise(function (resolve, reject) {\n                $.ajax({\n                    url: url,\n                    type: \"POST\",\n                    data: { message: message },\n                    success: function success(response) {\n                        resolve(response);\n                    },\n                    error: function error(_error) {\n                        reject(_error);\n                    }\n                });\n            }).then(function (response) {}.bind(this), function (error) {\n                console.log(\"Error:\", error);\n            });\n        }\n    }, {\n        key: 'render',\n        value: function render() {\n            return React.createElement(\n                'div',\n                null,\n                React.createElement(_ChatMessages2.default, { messages: this.state.messages }),\n                React.createElement(_ChatSendForm2.default, { onSendMessage: this.sendMessage })\n            );\n        }\n    }]);\n\n    return ChatApp;\n}(React.Component);\n\nexports.default = ChatApp;\n\n},{\"../SocketChannel\":1,\"./ChatMessages\":4,\"./ChatSendForm\":5}],4:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _ChatSingleMessage = require('./ChatSingleMessage');\n\nvar _ChatSingleMessage2 = _interopRequireDefault(_ChatSingleMessage);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar ChatMessages = function (_React$Component) {\n    _inherits(ChatMessages, _React$Component);\n\n    function ChatMessages() {\n        _classCallCheck(this, ChatMessages);\n\n        return _possibleConstructorReturn(this, Object.getPrototypeOf(ChatMessages).apply(this, arguments));\n    }\n\n    _createClass(ChatMessages, [{\n        key: 'render',\n        value: function render() {\n            return React.createElement(\n                'div',\n                null,\n                React.createElement(\n                    'h1',\n                    null,\n                    'Messages display here.'\n                ),\n                React.createElement(\n                    'ul',\n                    null,\n                    this.props.messages.map(function (data, index) {\n                        return React.createElement(_ChatSingleMessage2.default, { key: index, message: data.message, time: data.time });\n                    })\n                )\n            );\n        }\n    }]);\n\n    return ChatMessages;\n}(React.Component);\n\nexports.default = ChatMessages;\n\n},{\"./ChatSingleMessage\":6}],5:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar ChatSendForm = function (_React$Component) {\n    _inherits(ChatSendForm, _React$Component);\n\n    function ChatSendForm(props) {\n        _classCallCheck(this, ChatSendForm);\n\n        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(ChatSendForm).call(this, props));\n\n        _this.state = {\n            text: ''\n        };\n\n        _this.onChange = _this.onChange.bind(_this);\n        _this.sendMessage = _this.sendMessage.bind(_this);\n        return _this;\n    }\n\n    _createClass(ChatSendForm, [{\n        key: 'onChange',\n        value: function onChange(event) {\n            this.setState({ text: event.target.value });\n        }\n    }, {\n        key: 'sendMessage',\n        value: function sendMessage(event) {\n            event.preventDefault();\n            this.props.onSendMessage(this.state.text);\n            this.setState({ text: '' });\n        }\n    }, {\n        key: 'render',\n        value: function render() {\n            var text = this.state.text;\n\n            return React.createElement(\n                'form',\n                { onSubmit: this.sendMessage },\n                React.createElement('input', { value: text, onChange: this.onChange, placeholder: 'Write something...' }),\n                React.createElement(\n                    'button',\n                    null,\n                    'Send'\n                )\n            );\n        }\n    }]);\n\n    return ChatSendForm;\n}(React.Component);\n\nexports.default = ChatSendForm;\n\n},{}],6:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar ChatSingleMessage = function (_React$Component) {\n    _inherits(ChatSingleMessage, _React$Component);\n\n    function ChatSingleMessage() {\n        _classCallCheck(this, ChatSingleMessage);\n\n        return _possibleConstructorReturn(this, Object.getPrototypeOf(ChatSingleMessage).apply(this, arguments));\n    }\n\n    _createClass(ChatSingleMessage, [{\n        key: \"render\",\n        value: function render() {\n            return React.createElement(\n                \"li\",\n                null,\n                React.createElement(\n                    \"span\",\n                    null,\n                    \" \",\n                    this.props.message,\n                    \" \"\n                ),\n                React.createElement(\n                    \"span\",\n                    null,\n                    \" \",\n                    this.props.time,\n                    \" \"\n                )\n            );\n        }\n    }]);\n\n    return ChatSingleMessage;\n}(React.Component);\n\nexports.default = ChatSingleMessage;\n\n},{}]},{},[2]);\n"],"file":"app.js","sourceRoot":"/source/"}